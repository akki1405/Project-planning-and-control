# -*- coding: utf-8 -*-
"""Mehul_Kumar & Akshay kumar A3 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1775qkpsSWNuO9LP53Ukl_QHznbxB5CJA
"""

"""
Description: Model that conducts Earned value analysis.
Assignment:  A3 - Earned Value Analysis

Author: Mehulkumar Jariwala and Akshaykumar Dhorajiya

Due Date: 15TH NOV, 2021

Language: PYTHON

To Compile: In the command line, please run the following command:

        Q1_Mehul_and_Akshay.ipynb



Not Addressed: N/A

Input: Please note the following:
        1. Change the CSV filepath when inserting new CSV files.

Output: The following output is shown:
        1. Using matplotlib, a pngs are generated as well as saved in the directory: ./Q1_Plots/
        2. Plots include:
                - gantt charts for original and resource levelled schedule 
                - Q1 A Table - Computed ACWP, BCWP, BCWS, SPI, SP, CPI, CV from ev_analysis()
                - Q1 B Table - Computed ACWP/week, BCWP/week, BCWS/week and Actual Duration till Now from ev_analysis()
                - Q1 B EV Graph - a line graph showing the cumulative ACWP, BCWP and BCWS over the project duration
                - Q1 D Table - Showcasing the original and revised schedule data - ES, EF, LS, LF, Duration
        3. A text file is generated:
                - Q1 C Estimate Project Status.txt - EAC, EPD estimated values.
        4. Comparison between c and d has been showed at the end of the code

Algorithm: The following algorithms and data structures were utilised:
1. A class node to store information about tasks (ES, EF, LS, LF, TF, LF, preds, successors, is critical, planned cost, actual completed perc, actual cost till now)
2. To guarantee that the formulae to calculate the activity parameters are satisfied, a recursive forward and backward implementation is used.
3. To calculate ACWP, BCWP, and BCWS for each work, we employ predetermined formulas.
4. Following step 3, we may determine the SPI, SP, CPI, CV, ACWP/week, BCWP/week, and BCWS/week.
5. Nodes' project durations that weren't finished by the report date are updated.
6. To guarantee that task parameters are satisfied while a task's duration varies, we run forward/backward traversal once more.
7. The project time is updated and new task parameters (ES, EF, LS, and LF) are calculated.

Known Bugs: N/A
"""

from __future__ import annotations
import json
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
import numpy as np
import os
from pandas.plotting import table
import pandas as pd




class Node:
      

    

        # Initializer
        def __init__(self, task, duration):
                self.task = task
                self.duration = duration
                self.es = None
                self.ef = None
                self.ls = None
                self.lf = None
                self.tf = None
                self.ff = None

                self.previous = []
                self.next = []

                self.is_critical = "No"

                self.planned_cost = 0
                self.actual_complete_perc = 0
                self.actual_cost_till_now = 0

        # Function to print the Node object
        def __repr__(self) -> str:
                return "{" \
                       f"\"Task\":\"{self.task}\", " \
                       f"\"Duration\":\"{self.duration}\", " \
                       f"\"ES\":\"{self.es}\", " \
                       f"\"EF\":\"{self.ef}\", " \
                       f"\"LS\":\"{self.ls}\", " \
                       f"\"LF\":\"{self.lf}\", " \
                       f"\"TF\":\"{self.tf}\", " \
                       f"\"FF\":\"{self.ff}\", " \
                       f"\"previous\":\"{list(map(lambda node: node.task, self.previous))}\", " \
                       f"\"next\":\"{list(map(lambda node: node.task, self.next))}\", " \
                       f"\"Planned Cost\":\"{self.planned_cost}\", " \
                       f"\"Actual Complete %\":\"{self.actual_complete_perc}\", " \
                       f"\"Actual Cost Till Now\":\"{self.actual_cost_till_now}\", " \
                       f"\"Critical Path\":\"{self.is_critical}\"" \
                       "}\n"


# Read the csv file and returns a pandas df object
CSV_PATH = "/content/Assignment_3_updated.csv"
def read_csv(path):
        return pd.read_csv(path)


# Generates nodes from the input csv
def generate_nodes(csv) -> list[str, Node]:
        # Add the Start and End nodes manually
        nodes = {
                "Start": Node(task="Start", duration=0),
                "End": Node(task="End", duration=0)
        }

        csv = csv.rename(columns=lambda x: x.strip())
        columns = csv.columns

        # Iterate through the dataframe
        for index, row in csv.iterrows():
                if row["Task"] not in nodes:
                        # Add new nodes
                        task = row["Task"]
                        node = Node(task, row["Scheduled Duration (Week)"])
                 
                        if ("Planned Cost" in columns):
                                node.planned_cost = int(row["Planned Cost"].lstrip("$").replace(",", ""))
                        if ("Actual Complete%" in columns):
                                node.actual_complete_perc = row["Actual Complete%"]
                        if ("Actual Cost till Now" in columns):
                                node.actual_cost_till_now = int(
                                        row["Actual Cost till Now"].lstrip("$").replace(",", ""))

                        nodes[task] = node

        # Iterate to keep track of previous and next nodes
        for index, row in csv.iterrows():
                # Dependency list
                current = row["Task"].strip()
                dependents = row["Dependency"].strip().split(",")
                for dependent in dependents:
                        dependent = dependent.strip()
                        # All preds and successors
                        if dependent.isalnum():
                                nodes[current].previous.append(nodes[dependent])
                                nodes[dependent].next.append(nodes[current])

        # Connect the start and end nodes
        for node in filter(lambda node: node.task not in ["Start", "End"], nodes.values()):
                if not node.next:
                        node.next.append(nodes["End"])
                        nodes["End"].previous.append(node)

                if not node.previous:
                        node.previous.append(nodes["Start"])
                        nodes["Start"].next.append(node)

        return nodes


# Forward traversing - to set ES and EF values
def forward(end: Node):
        node = end
        max_es = 0

        for pred in node.previous:
                forward(end=pred)
                max_es = max(pred.ef,max_es)
        # Early start is the maximum value of preds EF values
        node.es = max_es
        node.ef = node.es + node.duration


# Backward traversing - to set LS and LF values
def backward(end: Node):
        node = end
        min_lf = np.double(np.inf)
        min_ff = np.double(np.inf)

        for successor in node.next:
                if (successor.task != "End"):
                        backward(end=successor)
                min_lf = min(min_lf, successor.ls)
                min_ff = min(min_lf, successor.es - node.ef)

        # Late finish is the minimum value of successors LS values
        node.lf = min_lf
        node.ls = node.lf - node.duration

        # Set is_critical to True if node is critical
        node.tf = node.ls - node.es

        if (node.tf == 0):
                node.is_critical = "Yes"

        node.ff = min_ff


def get_df_from_nodes(nodes):
        df = []
        for node in nodes.values():
                node_str = repr(node)
                node_dict = json.loads(node_str)
                df.append(node_dict)

        df = pd.DataFrame.from_dict(df)
        df.drop(columns=["previous", "next"], axis=1, inplace=True)
        df = df[~df["Task"].isin(["Start", "End"])]
        df['Color'] = df.apply(color, axis=1)

        return df
# Helper function to check if a node is critical
def is_critical(node):
        if node["Critical Path"] == "Yes":
                return True
        return False

# Identifies critical nodes and returns the number of critical nodes in the program
def set_critical_nodes(nodes):
        # Set is_critical to "Yes" if node is critical
        num_critical = 0
        for node in nodes.values():
                if (node.es - node.ls == 0):
                        node.is_critical = "Yes"
                        node.tf = 0
                        num_critical = num_critical + 1
                else:
                        node.tf = node.ls - node.es
        return num_critical





# Traverses all nodes and forms a (src, dest) tuple of only the critical nodes
def get_critical_edges(nodes):
        edges = []
        for curr in nodes.values():
                src_dict = json.loads(repr(curr))

                # Check is current node is critical
                if (not is_critical(src_dict)):
                        continue

                src = src_dict["Task"]
                # Loop through successors
                successors = src_dict["next"].lstrip("[").rstrip("]").split(",")
                if (successors != ['']):
                        for nxt in successors:
                                dest = json.loads(repr(nodes[nxt.lstrip(" '").rstrip("'")]))
                                # Check if destination is critical
                                if (is_critical(dest)):
                                        edges.append((src, dest["Task"]))

        return edges


# Represents a graph data structure using adjacency list
def make_graph(edges, N):
        adjlist = {}
        for (src, dest) in edges:
                if src not in adjlist:
                        adjlist[src] = {dest: 1}
                else:
                        # Add new dest node
                        adjlist[src][dest] = 1

        # Manually add the "End" node
        adjlist["End"] = {}
        return adjlist

# create a column with to color the critical path
def color(row):
        c_dict = {'Yes': '#E64646', 'No': '#3475D0'}
        return c_dict[row['Critical Path']]

# Save Histogram to directory
def save_histogram(df, title, proj_start, proj_end, xlabel, ylabel):
        resource_dict = {}

        # For each day, maintain total resources
        for i in range(proj_start, proj_end + 1):
                resource_dict[i] = 0

        # Parse through df and add resources for each day
        for index, row in df.iterrows():
                start_date = int(row["ES"]) + 1
                end_date = int(row["EF"])

                for i in range(start_date, end_date + 1):
                        resource_dict[i] = resource_dict[i] + int(row["Resources"])

        # Assumption: resources[day = 0] = resources[day = 1]
        resource_dict[0] = resource_dict[1]

        # Plot Histogram
        plt.bar(list(resource_dict.keys()), resource_dict.values())
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.xticks(list(resource_dict.keys()))
        plt.yticks(np.arange(proj_start, max(resource_dict.values()) + 4, 2.0))

        # Save the figure
        if not os.path.exists(f'./{title[0:2]}_Plots/'):
                os.makedirs(f'./{title[0:2]}_Plots/')

        plt.savefig(f'./{title[0:2]}_Plots/' + title + ".png")

        # Clear the current figure
        plt.clf()

        return resource_dict
# Save Gantt-Chart to directory
def save_gantt_chart(df, title, proj_start, proj_end, xlabel, ylabel):
        fig, ax = plt.subplots(1, figsize=(16, 6))

        # Plot Legends
        c_dict = {'Critical': '#E64646', 'Non-Critical': '#3475D0'}
        legend_elements = [Patch(facecolor=c_dict[i], label=i) for i in c_dict]
        plt.legend(handles=legend_elements)

        # Plot Ticks
        xticks = np.arange(0, proj_end + 2, 1)
        xticks_labels = np.arange(proj_start, proj_end + 2)

        ax.set_xticks(xticks)
        ax.set_xticklabels(xticks_labels[::1])

        # Gantt Chart
        ax.barh(df.Task, pd.to_numeric(df.Duration), left=pd.to_numeric(df.ES), color=df.Color)
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.gca().invert_yaxis()

        # Save the figure
        if not os.path.exists(f'./{title[0:2]}_Plots/'):
                os.makedirs(f'./{title[0:2]}_Plots/')

        plt.savefig(f'./{title[0:2]}_Plots/' + title + ".png")

        # Clear the current figure
        plt.clf()





# Generate a PNG from pandas dataframe
def save_table(df, title, str_):
        fig, ax = plt.subplots()
        # hide axes
        fig.patch.set_visible(False)
        ax.axis('off')
        ax.patch.set_facecolor('white')

        # Create a table from df values
        table = ax.table(cellText=df.values, colLabels=df.columns, loc='center')
        table.auto_set_font_size(False)
        table.set_fontsize(7.5)
        table.auto_set_column_width(col=list(range(len(df.columns))))
        table.scale(2,1)

        if (str_ is not None):
                plt.suptitle(f"{str_}")

        # plt.autoscale()
        plt.savefig(f'./{title[0:2]}_Plots/' + title + ".png", transparent=False)

        plt.clf()


# Plot a line graph - EARNED VALUE GRAPH
def ev_graph(df, title, proj_start, proj_end, report_date):
        acwp_dict = {}
        bcwp_dict = {}
        bcws_dict = {}

        # For each week, maintain acwp/bcwp/bcws
        for i in range(proj_start, proj_end + 1):
                acwp_dict[i] = 0
                bcwp_dict[i] = 0
                bcws_dict[i] = 0

        # Parse through df
        for index, row in df.iterrows():
                start_date = int(row["ES"]) + 1
                end_date = int(row["EF"]) + 1

                # For each week, accumulate the ACWP/BCWP/BCWS from all the tasks
                for i in range(start_date, end_date):
                        bcwp_dict[i] = (bcwp_dict[i] + int(row["BCWP/week"])) if ((report_date - i) >= 0) else (
                        bcwp_dict[i])
                        acwp_dict[i] = (acwp_dict[i] + int(row["ACWP/week"])) if ((report_date - i) >= 0) else (
                        acwp_dict[i])
                        
                        bcws_dict[i] = bcws_dict[i] + int(row["BCWS/week"])

        # Create a dataframe
        ev_df = pd.DataFrame(
                {
                        "ACWP": list(acwp_dict.values()),
                        "BCWP": list(bcwp_dict.values()),
                        "BCWS": list(bcws_dict.values())
                },
                index=[i for i in range(proj_end + 1)]
        )

        # Take cumulative sum of the values
        ev_df["ACWP"] = ev_df['ACWP'].cumsum()
        ev_df["BCWP"] = ev_df['BCWP'].cumsum()
        ev_df["BCWS"] = ev_df['BCWS'].cumsum()

        # For ACWP/BCWP consider cumsum only till report_date
        for index in range(report_date + 1, proj_end + 1):
                ev_df.loc[index, "ACWP"] = np.nan
                ev_df.loc[index, "BCWP"] = np.nan

        # Plot the graph
        lines = ev_df.plot.line()
        plt.plot(marker='o')
        plt.xlabel("Time (Weeks)")
        plt.ylabel("Cost")
        plt.title("EARNED VALUE GRAPH")
        plt.xticks(list(i for i in range(proj_end + 1)))

        plt.savefig(f'./{title[0:2]}_Plots/' + title + ".png")
        plt.clf()




nodes = None

# Performs earned value analysis based on the report_date
# Calculates ACWP, BCWP, BCWS, CPI, CV, SPI, SV, ACWP/week, BCWP/week and BCWS/week
def ev_analysis(df, report_date):

       

        # BCWP Calculations
        df["BCWP"] = df.apply(lambda row:
                # (Actual Complete % / 100) * Planned Cost
                np.double("{:.3f}".format(
                                (np.double(row["Actual Complete %"]) / 100.0) * int(row["Planned Cost"])
                        )
                ),
        axis=1)
         # ACWP is simply the Actual Cost Till Now
        df["ACWP"] = pd.to_numeric(df["Actual Cost Till Now"])

        # BCWS Calculations
        df["BCWS"] = df.apply(lambda row:
                # If, (EF - report_date) is negative, task has completed successfully before report_date.
                # Thus, BCWS = Planned Cost
                int(row["Planned Cost"]) if (int(row["EF"]) - report_date <= 0)
                # Elif, (report_date - ES) is negative, task has not started yet.
                # Thus, BCWS = 0
                else (0 if (report_date - int(row["ES"]) <= 0)
                        # Else, BCWS takes into consideration the proportion of the task completed so far.
                        # Thus, BCWS = ((report_date - ES) / Duration) * Planned Cost
                        else (
                                np.double("{:.3f}".format(
                                        ((report_date - int(row["ES"])) / int(row["Duration"])) * int(row["Planned Cost"]))
                                )
                        )
                ),
        axis=1)

        # CPI is BCWP / ACWP
        df["CPI"] = df.apply(lambda row:
                # Avoid division by 0
                0 if (row["BCWP"] == 0)
                else (
                        np.double("{:.3f}".format(
                                row["BCWP"] / row["ACWP"]
                                )
                        )
                ),
        axis=1)
        # ACWP/week
        df["ACWP/week"] = df.apply(lambda row:
                # If, (EF - report_date) is negative, task has been completed
                # Thus, ACWP/week = ACWP / Duration
                np.double("{:.3f}".format(
                        row["ACWP"] / int(row["Duration"]))
                ) if (int(row["EF"]) - report_date <= 0)
                # Elif, (ACWP = 0), task has not begun yet
                # Thus, ACWP/week = 0
                else (0 if (int(row["ACWP"]) == 0)
                        # Else, take into consideration the duration the task completed so far
                        # Thus, ACWP/week = ACWP / (report_date - ES)
                        else (np.double("{:.3f}".format(
                                        row["ACWP"] / (report_date - int(row["ES"])))
                                )
                        )
                ),
        axis=1)

        # CV is BCWP - ACWP
        df["CV"] = df.apply(lambda row: int(row["BCWP"] - row["ACWP"]), axis=1)

        # SPI is BCWP / BCWS
        df["SPI"] = df.apply(lambda row:
                # Avoid division by 0
                0 if (row["BCWP"] == 0)
                else (
                        np.double("{:.3f}".format(
                                row["BCWP"] / row["BCWS"]
                                )
                        )
                ),
        axis=1)

        # SV is BCWP - BCWS
        df["SV"] = df.apply(lambda row: int(row["BCWP"] - row["BCWS"]), axis=1)

       

       

        # BCWS/week is defined as (Planned Cost / Duration) irrespective of report_date
        df["BCWS/week"] = df.apply(lambda row:
                np.double("{:.3f}".format(
                        int(row["Planned Cost"]) / int(row["Duration"]))
                ),
        axis=1)
         # BCWP/week
        df["BCWP/week"] = df.apply(lambda row:
                # If, (EF - report_date) is negative, task has been completed
                # Thus, BCWP/week = BCWP / Duration
                np.double("{:.3f}".format(
                        row["BCWP"] / int(row["Duration"]))
                ) if (int(row["EF"]) - report_date <= 0)
                # Elif, (BCWP = 0), task has not begun yet
                # Thus, BCWP/week = 0
                else (0 if (int(row["BCWP"]) == 0)
                        # Else, take into consideration the duration the task completed so far
                        # Thus, BCWP/week = BCWP / (report_date - ES)
                        else (np.double("{:.3f}".format(
                                row["BCWP"] / (report_date - int(row["ES"])))
                                )
                        )
                ),
        axis=1)
        # Actual Duration till Now
        df["Actual Duration till Now"] = df.apply(lambda row:
                # If, (EF - report_date) is negative, task has been completed
                # Thus, Actual Duration till Now = Duration of the task
                int(row["Duration"]) if (int(row["EF"]) - report_date <= 0)
                # Elif, (report_date - ES) is negative, task has not started yet.
                # Thus, Actual Duration till Now = 0
                else (0 if (report_date - int(row["ES"]) <= 0)
                        # Else, take into consideration the duration the task completed so far
                        # Thus, Actual Duration till Now = (report_date - ES)
                        else (report_date - int(row["ES"])
                        )
                ),
        axis=1)

        return df

# Calculates revised duration based on report_date
def revise_duration(df, report_date):

        revised_dict = {}

        # Iterate through each task
        for index, row in df.iterrows():

                j = (row["ES"])
                es = int(j)
                k = (row["EF"])
                ef = int(k)
                task = row["Task"]
                g = int(row["Duration"])
                # If task has not started before the report_date, do nothing
                if (es >= report_date or np.double(row["Actual Complete %"] == 0.0)):
                        revised_dict[task] = g

                # Task started before report_date
                if (es < report_date):
                        # Check the complete %
                        complete_perc = np.double(row["Actual Complete %"])

                        # Activity already finished
                        if (complete_perc == 100.0):
                                # Activity completed as expected
                                if (ef <= report_date):
                                        revised_dict[task] = g

                                # Activity completed earlier than expected
                                else:
                                        # Update task duration
                                        revised_dict[task] = report_date - es

                        # Activity under progress
                        else:
                                adtn=(row["Actual Duration till Now"])
                                active_duration = int(adtn)
                                revised_dict[task] = np.double("{:.3f}".format((100 * active_duration)/(complete_perc)))

        # Add a new column
        df["Revised Duration"] = df["Task"].map(revised_dict)

        return {
                "DF": df,
                "Revised Duration": revised_dict
        }

# Updates the nodes based on the revised schedule
def update_schedule(nodes, revised_duration):

        # Traverse through the nodes
        for node in filter(lambda node: node.task not in ["Start", "End"], nodes.values()):
                # Update the duration
                node.duration = revised_duration[node.task]

        start = nodes["Start"]
        end = nodes["End"]

        # Populate earliest start and finish by recursing until the end node
        forward(end=end)

        # Update "end" late start and finish values
        end.ls = end.lf = end.es

        # Populate late start and finish by recursing until the start node
        backward(end=start)

        # Check for critical paths
        N = set_critical_nodes(nodes)

        updated_df = get_df_from_nodes(nodes)

        return updated_df

if __name__ == "__main__":
        # Get graph definition from CSV
        q = (input("Please enter the report date [int]: "))

        csv = read_csv(CSV_PATH)
        nodes = generate_nodes(csv)
        report_date = int(q)
        start = nodes["Start"]
        end = nodes["End"]
        
        # Populate earliest start and finish by recursing until the end node
        forward(end=end)

        # Update "end" late start and finish values
        end.ls = end.lf = end.es

        # Populate late start and finish by recursing until the start node
        backward(end=start)

        # Check for critical paths
        N = set_critical_nodes(nodes)

        # Prepare Database for Gantt-Chart
        df = get_df_from_nodes(nodes)

        proj_start = int(json.loads(repr(nodes["Start"]))["ES"])
        proj_end = int(json.loads(repr(nodes["End"]))["EF"])

        # Gantt-Chart
        save_gantt_chart(df, "Q1 Original Schedule", proj_start, proj_end, "Duration (Days)", "Tasks")

        # EV Analysis at the Report Date
        df = ev_analysis(df, report_date)

        ############################################################################################################

        df_a = df[['Task', 'ACWP', 'BCWP', 'BCWS', 'SPI', 'SV', 'CPI', 'CV']].copy()

        str_ = f"EV ANALYSIS\nProject Start: {proj_start}\nProject End: {proj_end}"
        save_table(df_a, "Q1 A Table", str_)

        ############################################################################################################

        df_b = df[["Task", "Duration", "Actual Duration till Now", "BCWS/week", "ACWP/week", "BCWP/week"]].copy()
        df_b.rename({'Duration': 'Planned Duration'}, axis=1, inplace= False)

        acwp_total = df["ACWP"].sum()
        bcwp_total = df["BCWP"].sum()
        bcws_total = df["BCWS"].sum()

        spi_project = bcwp_total / bcws_total
        sv_project = bcwp_total - bcws_total
        cpi_project = bcwp_total / acwp_total
        cv_project = bcwp_total - acwp_total

        print(f"\n==============\n" \
                f"ACWP TOTAL: {acwp_total}\n" \
                f"BCWP TOTAL: {bcwp_total}\n" \
                f"BCWS TOTAL: {bcws_total}\n" \
                f"SPI PROJECT: {spi_project}\n" \
                f"SV PROJECT: {sv_project}\n" \
                f"CPI PROJECT: {cpi_project}\n" \
                f"CV PROJECT: {cv_project}\n" \
                "==============\n")

        str_ = "EV ANALYSIS\n"
        if (spi_project >= 1):
                if (sv_project >= 0):
                        str_ =str_+ "The project is ahead of schedule"
                else:
                        str_ = str_+"The project is behind schedule"
        else:
                str_ = str_+ "The project is behind schedule"

        if (cv_project >= 0):
                if (cpi_project >= 1):
                        str_ =str_ + "The project is under budget" + "\n"
                else:
                        str_ =str_+ "The project is over budget" + "\n"
        else:
                str_ =str_ + "The project is over budget" + "\n"

        

        # Create a table - PNG
        save_table(df_b, "Q1 B Table", str_)
        

        # Generate line graph
        ev_graph(df, "Q1 B EV Graph", proj_start, proj_end, report_date)

        ############################################################################################################

        df["Planned Cost"] = pd.to_numeric(df["Planned Cost"])
        planned_cost_proj = df["Planned Cost"].sum()

        eac = planned_cost_proj/cpi_project
        epd = proj_end/spi_project

        # Write the Project Estimates in a file
        with open('./Q1 C Estimate Project Status.txt', 'w') as f:
                f.write("Estimate Status of the Project:\n\n")
                f.write(f"Estimate at completion (EAC): {eac}\n")
                f.write(f"Estimated project duration (EPD): {epd}\n")
        f.close()

        # Also print Project Estimates to a console
        print("Estimate at completion (EAC) in dollars: ", eac)
        print("Estimated project duration (EPD) in days: ", epd)
        print("\n==============")

        # ############################################################################################################

        # Per
        retval = revise_duration(df, report_date)
        df = retval["DF"]

        revised_duration = retval["Revised Duration"]
        df_d_1 = df[["Task", "Duration", "ES", "EF", "LS", "LF"]]
        df_d_1.rename({'ES': 'ES_o', 'EF': 'EF_o', 'LS': 'LS_o', 'LF': 'LF_o'}, axis=1, inplace=True)

        # Update schedule based on revised durations
        df_d_2 = update_schedule(nodes, revised_duration)
        df_d_2.drop(columns=['TF', 'FF', 'Planned Cost', 'Actual Complete %', 'Actual Cost Till Now', 'Critical Path', 'Color'], axis=1, inplace=True)
        df_d_2.rename({'ES': 'ES_r', 'EF': 'EF_r', 'LS': 'LS_r', 'LF': 'LF_r', "Duration": "Revised Duration"}, axis=1, inplace=True)

        # Merge original/revised schedules
        df_d = pd.merge(df_d_1, df_d_2,  how='inner', on=["Task"])

        # Calculate revised start/end dates
        proj_start = int(json.loads(repr(nodes["Start"]))["ES"])
        proj_end = int(np.double(json.loads(repr(nodes["End"]))["EF"]))

        str_ = f"Project Start: {proj_start}\nProject End: {proj_end}"
        save_table(df_d, "Q1 D Table", str_)
###########################################################################################################################################################################################################################################################################################################################################################################
        # comparison between c and d

        print('Section c calculates cost according to duration which is less than the results of section d. But in section d, delaying activity b which is on critical path which would results in increse in total project duration and project cost. So we can conclude that section c does not give reliable result while section d gives true result of the project.  ')